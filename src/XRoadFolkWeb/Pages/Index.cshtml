@page
@model XRoadFolkWeb.Pages.IndexModel
@inject Microsoft.AspNetCore.Mvc.Localization.IViewLocalizer IViewLocalizer
@{
    ViewData["Title"] = IViewLocalizer["Title"];
}

<h1 class="mb-4">@IViewLocalizer["Title"]</h1>

<div class="row g-4">
    <div class="col-12 col-lg-6">
        <div class="card shadow-sm">
            <div class="card-body">
                <h5 class="card-title">@IViewLocalizer["SearchCriteria"]</h5>
                <p class="text-muted mb-3">@IViewLocalizer["ProvideCriteria"]</p>

                <form method="post" class="row gy-3">
                    <div asp-validation-summary="ModelOnly" class="text-danger small"></div>

                    <div class="col-12">
                        <label asp-for="Ssn" class="form-label"></label>
                        <input asp-for="Ssn" class="form-control"
                               data-val-ssnornamedob="@XRoadFolkWeb.Resources.ValidationMessages.ProvideSsnOrNameDob"
                               data-val-ssnornamedob-ssn="Ssn"
                               data-val-ssnornamedob-first="FirstName"
                               data-val-ssnornamedob-last="LastName"
                               data-val-ssnornamedob-dob="DateOfBirth" />
                        <span asp-validation-for="Ssn" class="text-danger small"></span>
                    </div>

                    <div class="col-12">
                        <div class="text-center text-muted-sep">@IViewLocalizer["OrSeparator"]</div>
                    </div>

                    <div class="col-md-6">
                        <label asp-for="FirstName" class="form-label"></label>
                        <input asp-for="FirstName" class="form-control" />
                        <span asp-validation-for="FirstName" class="text-danger small"></span>
                    </div>
                    <div class="col-md-6">
                        <label asp-for="LastName" class="form-label"></label>
                        <input asp-for="LastName" class="form-control" />
                        <span asp-validation-for="LastName" class="text-danger small"></span>
                    </div>
                    <div class="col-12">
                        <label asp-for="DateOfBirth" class="form-label"></label>
                        <input asp-for="DateOfBirth" class="form-control" placeholder="@IViewLocalizer["DateFormatPlaceholder"]" />
                        <span asp-validation-for="DateOfBirth" class="text-danger small"></span>
                    </div>

                    <div class="col-12 d-grid d-sm-flex gap-2 mt-2">
                        <button type="submit" class="btn btn-primary">@IViewLocalizer["Search"]</button>
                        <button type="submit" asp-page-handler="Clear" class="btn btn-outline-secondary">@IViewLocalizer["Clear"]</button>
                    </div>
                </form>

                @if (Model.Errors?.Count > 0)
                {
                    <div class="alert alert-danger mt-3" role="alert">
                        <strong>@IViewLocalizer["InputErrors"]</strong>
                        <ul class="mb-0">
                            @foreach (var e in Model.Errors)
                            {
                                <li>@e</li>
                            }
                        </ul>
                    </div>
                }
            </div>
        </div>
    </div>

    <div class="col-12 col-lg-6">
        


            <script>
                (function () {
                    const key = document.getElementById('ppi-key')?.value || '';
                    const acc = document.getElementById('ppi-people-acc');
                    const expandAll = document.getElementById('ppi-persons-expand');
                    const collapseAll = document.getElementById('ppi-persons-collapse');

                    const inflight = new Map(); // index -> {promise, controller}

                    function getPersonXml(index) {
                        if (inflight.has(index)) return inflight.get(index).promise;
                        const controller = new AbortController();
                        const p = (async () => {
                            try {
                                const resp = await fetch(`?handler=PersonXml&index=${index}&key=${encodeURIComponent(key)}`, {
                                    headers: { 'Accept': 'application/xml' },
                                    signal: controller.signal
                                });
                                if (!resp.ok) throw new Error(await resp.text());
                                return await resp.text();
                            } finally {
                                inflight.delete(index);
                            }
                        })();
                        inflight.set(index, { promise: p, controller });
                        return p;
                    }

                    // on opening another item, cancel previous prefetches if needed
                    function cancelAllPrefetch() {
                        inflight.forEach(v => v.controller.abort());
                        inflight.clear();
                    }

                    async function fetchPersonXml(index) {
                        const url = `?handler=PersonXml&index=${index}&key=${encodeURIComponent(key)}`;
                        const resp = await fetch(url, { headers: { 'Accept': 'application/xml' } });
                        if (!resp.ok) throw new Error(await resp.text());
                        return await resp.text();
                    }

                    function buildTreeFromXml(xmlText) {
                        try {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(xmlText, 'application/xml');
                            if (doc.querySelector('parsererror')) return null;

                            function el(tag, cls, text) {
                                const e = document.createElement(tag);
                                if (cls) e.className = cls;
                                if (text != null) e.textContent = text;
                                return e;
                            }
                            function build(node) {
                                if (node.nodeType === 1) {
                                    const details = el('details', 'xml-node', null);
                                    const sum = el('summary', 'xml-summary', null);
                                    sum.appendChild(el('span', 'xml-name fw-bold', node.nodeName));
                                    if (node.attributes && node.attributes.length) {
                                        const attrs = Array.from(node.attributes).map(a => `${a.name}="${a.value}"`).join(' ');
                                        sum.appendChild(el('span', 'text-muted ms-2', attrs));
                                    }
                                    const hasChildren = Array.from(node.childNodes).some(n => n.nodeType === 1);
                                    const text = (node.textContent || '').trim();
                                    if (!hasChildren && text) {
                                        sum.appendChild(el('span', 'xml-text ms-2', `= "${text}"`));
                                    }
                                    details.appendChild(sum);
                                    Array.from(node.childNodes).forEach(ch => {
                                        if (ch.nodeType === 1) details.appendChild(build(ch));
                                    });
                                    return details;
                                }
                                return document.createTextNode('');
                            }
                            const tree = build(doc.documentElement);
                            tree.open = true;
                            return tree;
                        } catch { return null; }
                    }

                    function ensureLazyLoad(collapseEl) {
                        let loaded = false;
                        collapseEl.addEventListener('show.bs.collapse', async () => {
                            if (loaded) return;
                            const idx = collapseEl.getAttribute('data-index');
                            const host = document.getElementById(`ppi-host-${idx}`);
                            if (!host) return;
                            host.textContent = 'Loading…';
                            try {
                                const xml = await fetchPersonXml(idx);
                                const tree = buildTreeFromXml(xml);
                                host.innerHTML = '';
                                if (tree) host.appendChild(tree);
                                else {
                                    const pre = document.createElement('pre');
                                    pre.className = 'mb-0';
                                    pre.textContent = xml;
                                    host.appendChild(pre);
                                }
                                loaded = true;
                            } catch (e) {
                                host.innerHTML = `<span class="text-danger">Failed: ${e}</span>`;
                            }
                        });
                    }

                    // Wire lazy loads
                    acc?.querySelectorAll('.accordion-collapse').forEach(ensureLazyLoad);

                    // Expand/collapse all
                    expandAll?.addEventListener('click', () => {
                        acc.querySelectorAll('.accordion-collapse').forEach(c => c.classList.add('show'));
                    });
                    collapseAll?.addEventListener('click', () => {
                        acc.querySelectorAll('.accordion-collapse').forEach(c => c.classList.remove('show'));
                    });

                    // Copy/Download per person
                    acc?.addEventListener('click', async (e) => {
                        const btn = e.target.closest('button');
                        if (!btn) return;
                        const idx = btn.getAttribute('data-index');
                        if (!idx) return;

                        if (btn.classList.contains('ppi-copy-one')) {
                            try {
                                const xml = await fetchPersonXml(idx);
                                await navigator.clipboard.writeText(xml);
                                const old = btn.textContent; btn.textContent = 'Copied';
                                setTimeout(() => btn.textContent = old, 1200);
                            } catch { /* noop */ }
                        }
                        if (btn.classList.contains('ppi-dl-one')) {
                            const xml = await fetchPersonXml(idx);
                            const blob = new Blob([xml], { type: 'application/xml' });
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(blob);
                            a.download = `PersonPublicInfo_${(+idx + 1)}.xml`;
                            document.body.appendChild(a); a.click();
                            URL.revokeObjectURL(a.href); a.remove();
                        }
                    });

                    const observer = new IntersectionObserver(entries => {
                        entries.forEach(e => {
                            if (e.isIntersecting) {
                                const idx = +e.target.getAttribute('data-index');
                                // prefetch current and next two items
                                [idx, idx + 1, idx + 2].forEach(i => { if (i >= 0) getPersonXml(i).catch(() => {}); });
                                observer.unobserve(e.target);
                            }
                        });
                    }, { rootMargin: '200px' });

                    document.querySelectorAll('.accordion-collapse').forEach(el => observer.observe(el));
                })();
            </script>
        

        @if (!string.IsNullOrWhiteSpace(Model.PeoplePublicInfoResponseXml))
        {
            <div class="card shadow-sm mb-4">
                <div class="card-body">
                    <div class="d-flex flex-wrap gap-2 justify-content-between align-items-center mb-2">
                        <h5 class="card-title mb-0">GetPeoplePublicInfo response</h5>
                        <div class="d-flex flex-wrap gap-2 align-items-center">
                            <div class="btn-group" role="group" aria-label="View mode">
                                <button id="ppi-pretty" type="button" class="btn btn-sm btn-outline-secondary">Pretty</button>
                                <button id="ppi-raw" type="button" class="btn btn-sm btn-outline-secondary">Raw</button>
                                <button id="ppi-tree" type="button" class="btn btn-sm btn-outline-secondary">Tree</button>
                                <button id="ppi-summary" type="button" class="btn btn-sm btn-outline-secondary">Summary</button>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="ppi-mask">
                                <label class="form-check-label" for="ppi-mask">Mask sensitive</label>
                            </div>
                            <div class="input-group input-group-sm" style="width: 240px;">
                                <span class="input-group-text">Search</span>
                                <input id="ppi-search" type="text" class="form-control" placeholder="tag/value…">
                                <button id="ppi-clearsearch" class="btn btn-outline-secondary" type="button" title="Clear">×</button>
                            </div>
                            <div class="btn-group" role="group" aria-label="Tree commands">
                                <button id="ppi-expand" type="button" class="btn btn-sm btn-outline-secondary" disabled>Expand</button>
                                <button id="ppi-collapse" type="button" class="btn btn-sm btn-outline-secondary" disabled>Collapse</button>
                            </div>
                            <div class="btn-group" role="group" aria-label="Export">
                                <button id="ppi-copy" type="button" class="btn btn-sm btn-outline-secondary">Copy</button>
                                <button id="ppi-download" type="button" class="btn btn-sm btn-outline-secondary">Download</button>
                            </div>
                        </div>
                    </div>

                    <pre id="ppi-xml-pretty"
                         class="mb-0 small bg-body-tertiary p-3 border rounded"
                         style="white-space: pre; overflow: auto; max-height: 40vh;">@Model.PeoplePublicInfoResponseXmlPretty</pre>

                    <pre id="ppi-xml-raw"
                         class="mb-0 small bg-body-tertiary p-3 border rounded"
                         style="white-space: pre; overflow: auto; max-height: 40vh; display: none;">@Model.PeoplePublicInfoResponseXml</pre>

                    <div id="ppi-xml-tree"
                         class="mb-0 small bg-body-tertiary p-3 border rounded"
                         style="display:none; overflow:auto; max-height:40vh; font-family: var(--bs-font-monospace, ui-monospace, SFMono-Regular, Menlo, Consolas, monospace);">
                    </div>
                    <div id="ppi-xml-summary"
                         class="mb-0 small bg-body-tertiary p-3 border rounded"
                         style="display:none; overflow:auto; max-height:40vh;">
                    </div>
                </div>
            </div>

            <script>
                (function () {
                    const prettyBtn = document.getElementById('ppi-pretty');
                    const rawBtn = document.getElementById('ppi-raw');
                    const treeBtn = document.getElementById('ppi-tree');
                    const summaryBtn = document.getElementById('ppi-summary');
                    const copyBtn = document.getElementById('ppi-copy');
                    const downloadBtn = document.getElementById('ppi-download');
                    const expandBtn = document.getElementById('ppi-expand');
                    const collapseBtn = document.getElementById('ppi-collapse');
                    const maskChk = document.getElementById('ppi-mask');
                    const search = document.getElementById('ppi-search');
                    const clearSearch = document.getElementById('ppi-clearsearch');
                    const prePretty = document.getElementById('ppi-xml-pretty');
                    const preRaw = document.getElementById('ppi-xml-raw');
                    const treeHost = document.getElementById('ppi-xml-tree');
                    const summaryHost = document.getElementById('ppi-xml-summary');

                    // Overview
                    const fieldsList = document.getElementById('ppi-field-list');

                    let sourcePretty = prePretty.textContent ?? '';
                    let sourceRaw = preRaw.textContent ?? '';
                    const prefKey = 'ppi-pref-v1';
                    let mode = (localStorage.getItem(prefKey) && JSON.parse(localStorage.getItem(prefKey)).mode) || 'pretty';
                    const saved = localStorage.getItem(prefKey);
                    maskChk.checked = (saved && JSON.parse(saved).mask) || false;

                    function savePrefs() {
                        localStorage.setItem(prefKey, JSON.stringify({ mode, mask: maskChk.checked }));
                    }

                    function maskValue(val) {
                        if (!val) return val;
                        val = val.replace(/(<SSN>)([^<]+)(<\/SSN>)/gi, (_, a, mid, b) => {
                            const digits = (mid || '').replace(/\D/g, '');
                            if (!digits) return a + mid + b;
                            const masked = digits.length <= 3 ? '*'.repeat(digits.length)
                                : '*'.repeat(digits.length - 3) + digits.slice(-3);
                            return a + masked + b;
                        });
                        val = val.replace(/(<token>)([^<]+)(<\/token>)/gi, '$1***$3');
                        val = val.replace(/(Authorization\s*:\s*)([^\r\n]+)/gi, '$1***');
                        return val;
                    }

                    function getDisplayText(text) {
                        return maskChk.checked ? maskValue(text) : text;
                    }

                    function parseXml(text) {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'application/xml');
                        const err = doc.querySelector('parsererror');
                        if (err) throw new Error(err.textContent || 'Invalid XML');
                        return doc;
                    }

                    function el(tag, cls, text) {
                        const e = document.createElement(tag);
                        if (cls) e.className = cls;
                        if (text != null) e.textContent = text;
                        return e;
                    }

                    function xmlToString(node) {
                        return new XMLSerializer().serializeToString(node);
                    }

                    function getText(el, localName) {
                        const n = Array.from(el.children).find(c => c.localName === localName);
                        return (n && (n.textContent || '').trim()) || '';
                    }

                    function getNames(el, type) {
                        const names = el.querySelectorAll('Names > Name');
                        const filtered = Array.from(names).filter(n => getText(n, 'Type') === type);
                        if (type === 'FirstName') {
                            return filtered
                                .map(n => ({ order: parseInt(getText(n, 'Order') || '9999', 10), value: getText(n, 'Value') }))
                                .sort((a, b) => a.order - b.order)
                                .map(x => x.value)
                                .filter(Boolean)
                                .join(' ');
                        }
                        const first = filtered.find(n => true);
                        return first ? getText(first, 'Value') : '';
                    }

                    function buildTree(node) {
                        if (node.nodeType === 1) {
                            const details = el('details', 'xml-node', null);
                            details.open = false;

                            const sum = el('summary', 'xml-summary', null);
                            const name = el('span', 'xml-name fw-bold', node.nodeName);
                            sum.appendChild(name);

                            if (node.attributes && node.attributes.length) {
                                const attrs = Array.from(node.attributes).map(a => `${a.name}="${a.value}"`).join(' ');
                                sum.appendChild(el('span', 'text-muted ms-2', attrs));
                            }

                            const text = (node.textContent || '').trim();
                            const hasElementChildren = Array.from(node.childNodes).some(n => n.nodeType === 1);
                            if (!hasElementChildren && text) {
                                sum.appendChild(el('span', 'xml-text ms-2', `= "${text}"`));
                            }

                            details.appendChild(sum);

                            Array.from(node.childNodes).forEach(child => {
                                if (child.nodeType === 1) {
                                    details.appendChild(buildTree(child));
                                }
                            });

                            return details;
                        }
                        return document.createTextNode('');
                    }

                    function renderTree() {
                        treeHost.innerHTML = '';
                        try {
                            const xml = parseXml(getDisplayText(sourceRaw));
                            const root = xml.documentElement;
                            const tree = buildTree(root);
                            tree.open = true;
                            treeHost.appendChild(tree);
                        } catch (e) {
                            treeHost.textContent = 'Failed to render tree: ' + (e && e.message ? e.message : e);
                        }
                    }

                    // Summary (hierarchy grouping kept from your current file)
                    function renderSummary() {
                        summaryHost.innerHTML = '';
                        try {
                            const text = getDisplayText(sourceRaw);
                            const xml = parseXml(text);
                            const people = Array.from(xml.getElementsByTagName('*')).filter(el => el.localName === 'PersonPublicInfo');
                            if (people.length === 0) {
                                summaryHost.appendChild(el('div', 'text-muted', 'No PersonPublicInfo elements found.'));
                                return;
                            }

                            const isNil = (node) =>
                                node && node.nodeType === 1 &&
                                Array.from(node.attributes || []).some(a => a.localName === 'nil' && /^(true|1)$/i.test((a.value || '').trim()));

                            const hasElementChildren = (elx) => Array.from(elx.children).some(c => c.nodeType === 1 && !isNil(c));

                            const buildKvpTableForLeaves = (owner) => {
                                const leaves = Array.from(owner.children).filter(ch => !isNil(ch) && !hasElementChildren(ch));
                                if (leaves.length === 0) return null;
                                const t = document.createElement('table');
                                t.className = 'table table-sm table-striped align-middle mb-2';
                                const tb = document.createElement('tbody');
                                leaves.forEach(ch => {
                                    const tr = document.createElement('tr');
                                    const th = document.createElement('th');
                                    th.className = 'text-muted fw-normal';
                                    th.style.width = '40%';
                                    th.textContent = ch.localName;
                                    const td = document.createElement('td');
                                    td.textContent = (ch.textContent || '').trim();
                                    tr.appendChild(th); tr.appendChild(td);
                                    tb.appendChild(tr);
                                });
                                t.appendChild(tb);
                                return t;
                            };

                            const buildDetails = (node, titleOverride) => {
                                const d = document.createElement('details');
                                d.className = 'summary-group';
                                d.open = true;
                                const s = document.createElement('summary');
                                s.className = 'fw-semibold';
                                s.textContent = titleOverride || node.localName;
                                d.appendChild(s);

                                const leavesTable = buildKvpTableForLeaves(node);
                                if (leavesTable) d.appendChild(leavesTable);

                                const complex = Array.from(node.children).filter(ch => !isNil(ch) && hasElementChildren(ch));
                                complex.forEach(ch => d.appendChild(buildDetails(ch)));

                                return d;
                            };

                            const getTextLocal = (elx, name) => {
                                const n = Array.from(elx.children).find(c => c.localName === name);
                                return (n && (n.textContent || '').trim()) || '';
                            };

                            const getNamesSection = (person) => {
                                const namesRoot = Array.from(person.children).find(c => c.localName === 'Names');
                                if (!namesRoot) return null;

                                const names = Array.from(namesRoot.children).filter(n => n.localName === 'Name' && !isNil(n));
                                const byType = new Map();
                                names.forEach(n => {
                                    const type = getTextLocal(n, 'Type') || '-';
                                    const value = getTextLocal(n, 'Value') || '';
                                    const order = parseInt(getTextLocal(n, 'Order') || '9999', 10);
                                    if (!byType.has(type)) byType.set(type, []);
                                    byType.get(type).push({ value, order });
                                });

                                const wrap = document.createElement('details');
                                wrap.className = 'summary-group';
                                wrap.open = true;
                                const sum = document.createElement('summary');
                                sum.className = 'fw-semibold';
                                sum.textContent = 'Names';
                                wrap.appendChild(sum);

                                if (byType.size) {
                                    const t = document.createElement('table');
                                    t.className = 'table table-sm align-middle mb-2';
                                    const tb = document.createElement('tbody');
                                    Array.from(byType.entries()).sort((a, b) => a[0].localeCompare(b[0])).forEach(([type, arr]) => {
                                        arr.sort((a, b) => a.order - b.order);
                                        const tr = document.createElement('tr');
                                        const th = document.createElement('th');
                                        th.className = 'text-muted fw-normal';
                                        th.style.width = '40%';
                                        th.textContent = type;
                                        const td = document.createElement('td');
                                        td.textContent = arr.map(x => x.value).filter(Boolean).join(' ');
                                        tr.appendChild(th); tr.appendChild(td);
                                        tb.appendChild(tr);
                                    });
                                    t.appendChild(tb);
                                    wrap.appendChild(t);
                                }

                                if (names.length) {
                                    const list = document.createElement('div');
                                    list.className = 'd-flex flex-column gap-2';
                                    names.forEach((n, i) => {
                                        const card = document.createElement('div');
                                        card.className = 'p-2 border rounded';
                                        const t = buildKvpTableForLeaves(n);
                                        const title = document.createElement('div');
                                        title.className = 'small text-muted mb-1';
                                        title.textContent = `Name #${i + 1}`;
                                        card.appendChild(title);
                                        if (t) card.appendChild(t);
                                        list.appendChild(card);
                                    });
                                    wrap.appendChild(list);
                                }

                                return wrap;
                            };

                            people.forEach((p, i) => {
                                const wrap = document.createElement('div');
                                wrap.className = 'mb-3 p-2 border rounded';

                                // Header (friendly badges)
                                const header = document.createElement('div');
                                header.className = 'd-flex flex-wrap gap-2 align-items-baseline mb-2';
                                const idxBadge = document.createElement('span');
                                idxBadge.className = 'badge text-bg-secondary';
                                idxBadge.textContent = `#${i + 1}`;
                                header.appendChild(idxBadge);

                                const nameNodes = p.querySelectorAll('Names > Name');
                                const firsts = Array.from(nameNodes).filter(nm => getTextLocal(nm, 'Type') === 'FirstName')
                                    .map(nm => ({ order: parseInt(getTextLocal(nm, 'Order') || '9999', 10), v: getTextLocal(nm, 'Value') }))
                                    .sort((a, b) => a.order - b.order).map(x => x.v).filter(Boolean).join(' ');
                                const last = (() => {
                                    const nm = Array.from(nameNodes).find(nm => getTextLocal(nm, 'Type') === 'LastName');
                                    return nm ? getTextLocal(nm, 'Value') : '';
                                })();
                                const full = [firsts, last].filter(Boolean).join(' ');

                                const nameEl = document.createElement('strong');
                                nameEl.textContent = full || '-';
                                header.appendChild(nameEl);

                                const publicId = getTextLocal(p, 'PublicId') || getTextLocal(p, 'PersonId') || '';
                                const dob = (getTextLocal(p, 'CivilStatusDate') || getTextLocal(p, 'DateOfBirth') || '').slice(0, 10);
                                const status = getTextLocal(p, 'CivilStatus') || '';

                                if (publicId) {
                                    const b = document.createElement('span');
                                    b.className = 'badge text-bg-light';
                                    b.textContent = `PublicId: ${publicId}`;
                                    header.appendChild(b);
                                }
                                if (dob) {
                                    const b = document.createElement('span');
                                    b.className = 'badge text-bg-light';
                                    b.textContent = `DOB: ${dob}`;
                                    header.appendChild(b);
                                }
                                if (status) {
                                    const b = document.createElement('span');
                                    b.className = 'badge text-bg-light';
                                    b.textContent = `Status: ${status}`;
                                    header.appendChild(b);
                                }
                                wrap.appendChild(header);

                                // Basics
                                const basicsOwner = document.createElement('details');
                                basicsOwner.className = 'summary-group';
                                basicsOwner.open = true;
                                const basicsSum = document.createElement('summary');
                                basicsSum.className = 'fw-semibold';
                                basicsSum.textContent = 'Basics';
                                basicsOwner.appendChild(basicsSum);

                                const basicsTable = buildKvpTableForLeaves({
                                    children: Array.from(p.children).filter(ch =>
                                        ch.localName !== 'Names' &&
                                        !isNil(ch) &&
                                        !Array.from(ch.children).some(k => k.nodeType === 1)
                                    )
                                });
                                if (basicsTable) {
                                    basicsOwner.appendChild(basicsTable);
                                    wrap.appendChild(basicsOwner);
                                }

                                const namesSection = getNamesSection(p);
                                if (namesSection) wrap.appendChild(namesSection);

                                const complexGroups = Array.from(p.children).filter(ch =>
                                    !isNil(ch) && ch.localName !== 'Names' && hasElementChildren(ch));

                                complexGroups.forEach(group => {
                                    const kids = Array.from(group.children).filter(k => !isNil(k));
                                    const counts = kids.reduce((m, k) => (m[k.localName] = (m[k.localName] || 0) + 1, m), {});
                                    const repeatedName = Object.keys(counts).find(n => counts[n] > 1);

                                    const d = document.createElement('details');
                                    d.className = 'summary-group';
                                    d.open = true;
                                    const s = document.createElement('summary');
                                    s.className = 'fw-semibold';
                                    s.textContent = group.localName;
                                    d.appendChild(s);

                                    if (repeatedName) {
                                        const items = kids.filter(k => k.localName === repeatedName);
                                        const list = document.createElement('div');
                                        list.className = 'd-flex flex-column gap-2';
                                        items.forEach((item, idx) => {
                                            const card = document.createElement('div');
                                            card.className = 'p-2 border rounded';
                                            const title = document.createElement('div');
                                            title.className = 'small text-muted mb-1';
                                            title.textContent = `${repeatedName} #${idx + 1}`;
                                            card.appendChild(title);

                                            const leaves = buildKvpTableForLeaves(item);
                                            if (leaves) card.appendChild(leaves);

                                            const nestedComplex = Array.from(item.children).filter(ch => !isNil(ch) && hasElementChildren(ch));
                                            nestedComplex.forEach(ch => card.appendChild(buildDetails(ch)));

                                            list.appendChild(card);
                                        });
                                        d.appendChild(list);
                                    } else {
                                        const leaves = buildKvpTableForLeaves(group);
                                        if (leaves) d.appendChild(leaves);
                                        const subComplex = kids.filter(ch => hasElementChildren(ch));
                                        subComplex.forEach(ch => d.appendChild(buildDetails(ch)));
                                    }

                                    wrap.appendChild(d);
                                });

                                summaryHost.appendChild(wrap);
                            });
                        } catch (e) {
                            summaryHost.textContent = 'Failed to build summary: ' + (e && e.message ? e.message : e);
                        }
                    }

                    // Search only applies to Tree view
                    function applySearch() {
                        const q = (search?.value || '').trim();
                        if (mode === 'tree') {
                            const ql = q.toLowerCase();
                            // reset state
                            treeHost.querySelectorAll('.xml-node, .xml-summary')
                                .forEach(e => e.classList.remove('d-none', 'bg-warning-subtle'));
                            if (!ql) return;

                            // hide all nodes then reveal matches and ancestors
                            treeHost.querySelectorAll('.xml-node').forEach(d => d.classList.add('d-none'));
                            treeHost.querySelectorAll('.xml-summary').forEach(s => {
                                const txt = (s.textContent || '').toLowerCase();
                                if (txt.includes(ql)) {
                                    s.classList.add('bg-warning-subtle');
                                    let p = s.parentElement;
                                    while (p && p !== treeHost) {
                                        if (p.classList.contains('xml-node')) {
                                            p.classList.remove('d-none');
                                            p.open = true;
                                        }
                                        p = p.parentElement;
                                    }
                                } else {
                                    s.classList.remove('bg-warning-subtle');
                                }
                            });
                            return;
                        }

                        if (mode === 'summary') {
                            const items = Array.from(summaryHost.children).filter(n => n.nodeType === 1);
                            if (!q) { items.forEach(el => el.classList.remove('d-none')); return; }
                            const ql = q.toLowerCase();
                            items.forEach(el => {
                                const match = (el.textContent || '').toLowerCase().includes(ql);
                                el.classList.toggle('d-none', !match);
                            });
                            return;
                        }

                        // Raw/Pretty: highlight in PRE
                        if (mode === 'raw')  highlightPre(preRaw,   sourceRaw,   q);
                        if (mode === 'pretty') highlightPre(prePretty, sourcePretty, q);
                    }

                    // Inside the “GetPeoplePublicInfo response” IIFE, add this block near the other button wiring, BEFORE `// init` + `updateView();`
                    function getExportText() {
                        // Respect current mode and mask setting
                        if (mode === 'raw')    return getDisplayText(sourceRaw || preRaw?.textContent || '');
                        if (mode === 'pretty') return getDisplayText(sourcePretty || prePretty?.textContent || '');
                        // Tree/Summary don’t map to one XML; export Pretty as default
                        return getDisplayText(sourcePretty || prePretty?.textContent || '');
                    }

                    copyBtn?.addEventListener('click', async (e) => {
                        e.preventDefault();
                        const text = getExportText();
                        try {
                            await navigator.clipboard.writeText(text);
                        } catch {
                            // Fallback for non-secure contexts/older browsers
                            const ta = document.createElement('textarea');
                            ta.value = text;
                            ta.style.position = 'fixed';
                            ta.style.left = '-10000px';
                            document.body.appendChild(ta);
                            ta.select();
                            try { document.execCommand('copy'); } catch {}
                            ta.remove();
                        }
                        const old = copyBtn.innerText;
                        copyBtn.innerText = 'Copied';
                        setTimeout(() => copyBtn.innerText = old, 1200);
                    });

                    downloadBtn?.addEventListener('click', (e) => {
                        e.preventDefault();
                        const text = getExportText();
                        const name =
                            mode === 'raw' ? 'GetPeoplePublicInfo_raw.xml' :
                            mode === 'pretty' ? 'GetPeoplePublicInfo_pretty.xml' :
                            mode === 'tree' ? 'GetPeoplePublicInfo_from_tree.xml' :
                            mode === 'summary' ? 'GetPeoplePublicInfo_summary.xml' :
                            'GetPeoplePublicInfo.xml';

                        const blob = new Blob([text], { type: 'application/xml;charset=utf-8' });
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = name;
                        document.body.appendChild(a);
                        a.click();
                        URL.revokeObjectURL(a.href);
                        a.remove();
                    });

                    // Expand/Collapse for tree
                    function expandAll(open) {
                        treeHost.querySelectorAll('details.xml-node').forEach(d => d.open = open);
                    }
                    expandBtn?.addEventListener('click', () => expandAll(true));
                    collapseBtn?.addEventListener('click', () => expandAll(false));

                    // Mode + mask
                    prettyBtn?.addEventListener('click', () => { mode = 'pretty'; updateView(); });
                    rawBtn?.addEventListener('click', () => { mode = 'raw'; updateView(); });
                    treeBtn?.addEventListener('click', () => { mode = 'tree'; updateView(); });
                    summaryBtn?.addEventListener('click', () => { mode = 'summary'; updateView(); });
                    maskChk?.addEventListener('change', () => updateView());

                    // Public API (optional) to push new XML into v2 viewer
                    window.ppi2SetResponseXml = function (newRaw, newPretty) {
                        if (typeof newRaw === 'string') sourceRaw = newRaw;
                        if (typeof newPretty === 'string') sourcePretty = newPretty;
                        preRaw.textContent = getDisplayText(sourceRaw);
                        prePretty.textContent = getDisplayText(sourcePretty);
                        updateView();
                    };

                    // Init
                    updateView();
                })();
            </script>
        }

        @if (Model.PersonDetails is not null)
        {
            <div class="card shadow-sm mt-4">
                <div class="card-body">
                    <h5 class="card-title">@IViewLocalizer["PersonDetails"]@Model.SelectedNameSuffix</h5>

                    @{
                        var groups = Model.PersonDetails
                        .GroupBy(p => p.Key.Contains('.') ? p.Key[..p.Key.IndexOf('.')] : p.Key)
                        .OrderBy(g => g.Key)
                        .ToList();
                        var accId = "personDetailsAcc";
                        var gIndex = 0;
                    }

                    <div class="accordion" id="@accId">
                        @foreach (var grp in groups)
                        {
                            var headingId = $"pd-h-{gIndex}";
                            var collapseId = $"pd-c-{gIndex}";
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="@headingId">
                                    <button class="accordion-button collapsed" type="button"
                                            data-bs-toggle="collapse" data-bs-target="#@collapseId"
                                            aria-expanded="false" aria-controls="@collapseId">
                                        @grp.Key
                                    </button>
                                </h2>
                                <div id="@collapseId" class="accordion-collapse collapse"
                                     aria-labelledby="@headingId" data-bs-parent="#@accId">
                                    <div class="accordion-body p-0">
                                        <div class="table-responsive">
                                            <table class="table table-sm table-striped align-middle mb-0">
                                                <tbody>
                                                    @foreach (var (k, v) in grp.OrderBy(x => x.Key))
                                                    {
                                                        var lastDot = k.LastIndexOf('.');
                                                        var subKey = lastDot >= 0 ? k[(lastDot + 1)..] : k;
                                                        var bracketPos = subKey.IndexOf('[');
                                                        if (bracketPos >= 0) subKey = subKey[..bracketPos];

                                                        <tr>
                                                            <th class="text-muted fw-normal" style="width: 35%; word-break: break-word;">
                                                                @subKey
                                                            </th>
                                                            <td style="word-break: break-word;">@v</td>
                                                        </tr>
                                                    }
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            gIndex++;
                        }
                    </div>
                </div>
            </div>
        }
    </div>
</div>

@{
    var t = IViewLocalizer["Title"];
}

<environment include="Development">
    <script src="/_framework/aspnetcore-browser-refresh.js"></script>
</environment>

@section Scripts {
    <partial name="_ValidationScriptsPartial" />
    <script src="~/js/validation-ssn.js"></script>
    <script src="~/js/validation-name.js"></script>
    <script src="~/js/validation-dob.js"></script>
    <script src="~/js/validation-ssn-or-name-dob.js"></script>
    <script src="~/js/validation-letters-only.js"></script>
    <script>
        // Inside the “GetPeoplePublicInfo response” IIFE, add this block near the other button wiring, BEFORE `// init` + `updateView();`
        function getExportText() {
            // Respect current mode and mask setting
            if (mode === 'raw')    return getDisplayText(sourceRaw || preRaw?.textContent || '');
            if (mode === 'pretty') return getDisplayText(sourcePretty || prePretty?.textContent || '');
            // Tree/Summary don’t map to one XML; export Pretty as default
            return getDisplayText(sourcePretty || prePretty?.textContent || '');
        }

        copyBtn?.addEventListener('click', async (e) => {
            e.preventDefault();
            const text = getExportText();
            try {
                await navigator.clipboard.writeText(text);
            } catch {
                // Fallback for non-secure contexts/older browsers
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.left = '-10000px';
                document.body.appendChild(ta);
                ta.select();
                try { document.execCommand('copy'); } catch {}
                ta.remove();
            }
            const old = copyBtn.innerText;
            copyBtn.innerText = 'Copied';
            setTimeout(() => copyBtn.innerText = old, 1200);
        });

        downloadBtn?.addEventListener('click', (e) => {
            e.preventDefault();
            const text = getExportText();
            const name =
                mode === 'raw' ? 'GetPeoplePublicInfo_raw.xml' :
                mode === 'pretty' ? 'GetPeoplePublicInfo_pretty.xml' :
                mode === 'tree' ? 'GetPeoplePublicInfo_from_tree.xml' :
                mode === 'summary' ? 'GetPeoplePublicInfo_summary.xml' :
                'GetPeoplePublicInfo.xml';

            const blob = new Blob([text], { type: 'application/xml;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(a.href);
            a.remove();
        });
    </script>
}


@* ===== NEW: GetPeoplePublicInfo response (v2) — self-contained viewer with working Copy/Download ===== *@
@if (!string.IsNullOrWhiteSpace(Model.PeoplePublicInfoResponseXml))
{
    <div class="card shadow-sm mb-4">
        <div class="card-body">
            <div class="d-flex flex-wrap gap-2 justify-content-between align-items-center mb-2">
                <h5 class="card-title mb-0">GetPeoplePublicInfo response (new)</h5>
                <div class="d-flex flex-wrap gap-2 align-items-center">
                    <div class="btn-group" role="group" aria-label="View mode (v2)">
                        <button id="ppi2-pretty" type="button" class="btn btn-sm btn-outline-secondary">Pretty</button>
                        <button id="ppi2-raw" type="button" class="btn btn-sm btn-outline-secondary">Raw</button>
                        <button id="ppi2-tree" type="button" class="btn btn-sm btn-outline-secondary">Tree</button>
                        <button id="ppi2-summary" type="button" class="btn btn-sm btn-outline-secondary">Summary</button>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" id="ppi2-mask">
                        <label class="form-check-label" for="ppi2-mask">Mask sensitive</label>
                    </div>
                    @* NEW: Search (v2) *@
                    <div class="input-group input-group-sm" style="width: 240px;">
                        <span class="input-group-text">Search</span>
                        <input id="ppi2-search" type="text" class="form-control" placeholder="tag/value…">
                        <button id="ppi2-clearsearch" class="btn btn-outline-secondary" type="button" title="Clear">×</button>
                    </div>
                    <div class="btn-group" role="group" aria-label="Tree commands (v2)">
                        <button id="ppi2-expand" type="button" class="btn btn-sm btn-outline-secondary" disabled>Expand</button>
                        <button id="ppi2-collapse" type="button" class="btn btn-sm btn-outline-secondary" disabled>Collapse</button>
                    </div>
                    <div class="btn-group" role="group" aria-label="Export (v2)">
                        <button id="ppi2-copy" type="button" class="btn btn-sm btn-outline-secondary">Copy</button>
                        <button id="ppi2-download" type="button" class="btn btn-sm btn-outline-secondary">Download</button>
                    </div>
                </div>
            </div>

            <pre id="ppi2-xml-pretty"
                 class="mb-0 small bg-body-tertiary p-3 border rounded"
                 style="white-space: pre; overflow: auto; max-height: 40vh;">@Model.PeoplePublicInfoResponseXmlPretty</pre>

            <pre id="ppi2-xml-raw"
                 class="mb-0 small bg-body-tertiary p-3 border rounded"
                 style="white-space: pre; overflow: auto; max-height: 40vh; display:none;">@Model.PeoplePublicInfoResponseXml</pre>

            <div id="ppi2-xml-tree"
                 class="mb-0 small bg-body-tertiary p-3 border rounded"
                 style="display:none; overflow:auto; max-height:40vh; font-family: var(--bs-font-monospace, ui-monospace, SFMono-Regular, Menlo, Consolas, monospace);">
            </div>

            <div id="ppi2-xml-summary"
                 class="mb-0 small bg-body-tertiary p-3 border rounded"
                 style="display:none; overflow:auto; max-height:40vh;">
            </div>
        </div>
    </div>

    <script>
        (function () {
            // Elements
            const prettyBtn = document.getElementById('ppi2-pretty');
            const rawBtn = document.getElementById('ppi2-raw');
            const treeBtn = document.getElementById('ppi2-tree');
            const summaryBtn = document.getElementById('ppi2-summary');
            const copyBtn = document.getElementById('ppi2-copy');
            const downloadBtn = document.getElementById('ppi2-download');
            const expandBtn = document.getElementById('ppi2-expand');
            const collapseBtn = document.getElementById('ppi2-collapse');
            const maskChk = document.getElementById('ppi2-mask');
            const search = document.getElementById('ppi2-search');
            const clearSearch = document.getElementById('ppi2-clearsearch');
            const prePretty = document.getElementById('ppi2-xml-pretty');
            const preRaw = document.getElementById('ppi2-xml-raw');
            const treeHost = document.getElementById('ppi2-xml-tree');
            const summaryHost = document.getElementById('ppi2-xml-summary');

            // State
            let sourcePretty = prePretty?.textContent ?? '';
            let sourceRaw = preRaw?.textContent ?? '';
            const prefKey = 'ppi2-pref-v1';
            const saved = localStorage.getItem(prefKey);
            let mode = (saved && JSON.parse(saved).mode) || 'pretty';
            maskChk.checked = (saved && JSON.parse(saved).mask) || false;

            // Utils
            function savePrefs() {
                localStorage.setItem(prefKey, JSON.stringify({ mode, mask: maskChk.checked }));
            }
            function maskValue(val) {
                if (!val) return val;
                // Mask SSN values and tokens
                val = val.replace(/(<SSN>)([^<]+)(<\/SSN>)/gi, (_, a, mid, b) => {
                    const digits = (mid || '').replace(/\D/g, '');
                    if (!digits) return a + mid + b;
                    const masked = digits.length <= 3 ? '*'.repeat(digits.length)
                        : '*'.repeat(digits.length - 3) + digits.slice(-3);
                    return a + masked + b;
                });
                val = val.replace(/(<token>)([^<]+)(<\/token>)/gi, '$1***$3');
                val = val.replace(/(Authorization\s*:\s*)([^\r\n]+)/gi, '$1***');
                return val;
            }
            function getDisplayText(text) {
                return maskChk.checked ? maskValue(text) : text;
            }
            function parseXml(text) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'application/xml');
                const err = doc.querySelector('parsererror');
                if (err) throw new Error(err.textContent || 'Invalid XML');
                return doc;
            }
            function el(tag, cls, text) {
                const e = document.createElement(tag);
                if (cls) e.className = cls;
                if (text != null) e.textContent = text;
                return e;
            }

            // Tree
            function buildTreeNode(node) {
                if (node.nodeType !== 1) return document.createTextNode('');
                const details = el('details', 'xml-node', null);
                details.open = false;
                const sum = el('summary', 'xml-summary', null);
                sum.appendChild(el('span', 'xml-name fw-bold', node.nodeName));
                if (node.attributes && node.attributes.length) {
                    const attrs = Array.from(node.attributes).map(a => `${a.name}="${a.value}"`).join(' ');
                    sum.appendChild(el('span', 'text-muted ms-2', attrs));
                }
                const hasElementChildren = Array.from(node.childNodes).some(n => n.nodeType === 1);
                const text = (node.textContent || '').trim();
                if (!hasElementChildren && text) {
                    sum.appendChild(el('span', 'xml-text ms-2', `= "${text}"`));
                }
                details.appendChild(sum);
                Array.from(node.childNodes).forEach(ch => {
                    if (ch.nodeType === 1) details.appendChild(buildTreeNode(ch));
                });
                return details;
            }
            function renderTree() {
                treeHost.innerHTML = '';
                try {
                    const xml = parseXml(getDisplayText(sourceRaw));
                    const tree = buildTreeNode(xml.documentElement);
                    tree.open = true;
                    treeHost.appendChild(tree);
                } catch (e) {
                    treeHost.textContent = 'Failed to render tree: ' + (e?.message || e);
                }
            }

            // Summary (lightweight)
            function renderSummary() {
                summaryHost.innerHTML = '';
                try {
                    const xml = parseXml(getDisplayText(sourceRaw));
                    const people = Array.from(xml.getElementsByTagName('*')).filter(x => x.localName === 'PersonPublicInfo');
                    const header = el('div', 'mb-2', null);
                    header.appendChild(el('strong', null, `People count: ${people.length}`));
                    summaryHost.appendChild(header);

                    if (people.length === 0) {
                        summaryHost.appendChild(el('div', 'text-muted', 'No PersonPublicInfo elements found.'));
                        return;
                    }

                    const list = document.createElement('div');
                    list.className = 'd-flex flex-column gap-2';
                    const getText = (elx, name) => {
                        const n = Array.from(elx.children).find(c => c.localName === name);
                        return (n && (n.textContent || '').trim()) || '';
                    };

                    people.forEach((p, i) => {
                        const card = el('div', 'p-2 border rounded', null);
                        const title = el('div', 'small text-muted mb-1', `#${i + 1}`);
                        card.appendChild(title);

                        // Try to compose a name if Names present
                        const names = Array.from(p.querySelectorAll('Names > Name'));
                        const firsts = names
                            .filter(n => getText(n, 'Type') === 'FirstName')
                            .map(n => ({ o: parseInt(getText(n, 'Order') || '9999', 10), v: getText(n, 'Value') }))
                            .sort((a, b) => a.o - b.o).map(x => x.v).join(' ');
                        const last = (names.find(n => getText(n, 'Type') === 'LastName') && getText(names.find(n => getText(n, 'Type') === 'LastName'), 'Value')) || '';
                        const full = [firsts, last].filter(Boolean).join(' ');

                        const nameRow = el('div', null, null);
                        nameRow.appendChild(el('strong', null, full || '(no name)'));
                        card.appendChild(nameRow);

                        const pid = getText(p, 'PublicId') || getText(p, 'PersonId') || '';
                        const dob = (getText(p, 'DateOfBirth') || '').slice(0, 10);
                        const meta = el('div', 'mt-1', null);
                        if (pid) meta.appendChild(el('span', 'badge text-bg-light me-2', `PublicId: ${pid}`));
                        if (dob) meta.appendChild(el('span', 'badge text-bg-light', `DOB: ${dob}`));
                        if (meta.childNodes.length) card.appendChild(meta);

                        list.appendChild(card);
                    });
                    summaryHost.appendChild(list);
                } catch (e) {
                    summaryHost.textContent = 'Failed to build summary: ' + (e?.message || e);
                }
            }

            // View
            function setActive() {
                [prettyBtn, rawBtn, treeBtn, summaryBtn].forEach(b => b && b.classList.remove('active'));
                if (mode === 'pretty') prettyBtn?.classList.add('active');
                if (mode === 'raw') rawBtn?.classList.add('active');
                if (mode === 'tree') treeBtn?.classList.add('active');
                if (mode === 'summary') summaryBtn?.classList.add('active');
            }
            function updateView() {
                prePretty.style.display = (mode === 'pretty') ? 'block' : 'none';
                preRaw.style.display = (mode === 'raw') ? 'block' : 'none';
                treeHost.style.display = (mode === 'tree') ? 'block' : 'none';
                summaryHost.style.display = (mode === 'summary') ? 'block' : 'none';

                // Re-apply mask to PREs
                prePretty.textContent = getDisplayText(sourcePretty);
                preRaw.textContent = getDisplayText(sourceRaw);

                const treeActive = mode === 'tree';
                if (expandBtn) expandBtn.disabled = !treeActive;
                if (collapseBtn) collapseBtn.disabled = !treeActive;

                if (treeActive) renderTree();
                if (mode === 'summary') renderSummary();

                setActive();
                savePrefs();
            }

            // Export
            function getExportText() {
                if (mode === 'raw') return getDisplayText(sourceRaw || preRaw?.textContent || '');
                if (mode === 'pretty') return getDisplayText(sourcePretty || prePretty?.textContent || '');
                return getDisplayText(sourcePretty || prePretty?.textContent || '');
            }
            copyBtn?.addEventListener('click', async (e) => {
                e.preventDefault();
                const text = getExportText();
                try {
                    await navigator.clipboard.writeText(text);
                } catch {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    ta.style.position = 'fixed';
                    ta.style.left = '-10000px';
                    document.body.appendChild(ta);
                    ta.select();
                    try { document.execCommand('copy'); } catch {}
                    ta.remove();
                }
                const old = copyBtn.innerText;
                copyBtn.innerText = 'Copied';
                setTimeout(() => copyBtn.innerText = old, 1200);
            });
            downloadBtn?.addEventListener('click', (e) => {
                e.preventDefault();
                const text = getExportText();
                const name =
                    mode === 'raw' ? 'GetPeoplePublicInfo_raw.xml' :
                    mode === 'pretty' ? 'GetPeoplePublicInfo_pretty.xml' :
                    mode === 'tree' ? 'GetPeoplePublicInfo_from_tree.xml' :
                    mode === 'summary' ? 'GetPeoplePublicInfo_summary.xml' :
                    'GetPeoplePublicInfo.xml';
                const blob = new Blob([text], { type: 'application/xml;charset=utf-8' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = name;
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(a.href);
                a.remove();
            });

            // Search (v2)
            function escapeRegExp(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
            function escapeHtml(s) {
                return s.replace(/[&<>"']/g, ch => ({
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
                })[ch]);
            }
            function highlightPre(preEl, sourceText, q) {
                if (!preEl) return;
                if (!q) { preEl.textContent = getDisplayText(sourceText); return; }
                const rx = new RegExp(escapeRegExp(q), 'gi');
                const masked = getDisplayText(sourceText);
                const html = escapeHtml(masked).replace(rx, m => `<mark>${escapeHtml(m)}</mark>`);
                preEl.innerHTML = html; // escaped + marked
            }

            function applySearch() {
                const q = (search?.value || '').trim();

                if (mode === 'tree') {
                    const ql = q.toLowerCase();
                    treeHost.querySelectorAll('.xml-node, .xml-summary')
                        .forEach(e => e.classList.remove('d-none', 'bg-warning-subtle'));
                    if (!ql) return;

                    treeHost.querySelectorAll('.xml-node').forEach(d => d.classList.add('d-none'));
                    treeHost.querySelectorAll('.xml-summary').forEach(s => {
                        const txt = (s.textContent || '').toLowerCase();
                        if (txt.includes(ql)) {
                            s.classList.add('bg-warning-subtle');
                            let p = s.parentElement;
                            while (p && p !== treeHost) {
                                if (p.classList.contains('xml-node')) {
                                    p.classList.remove('d-none');
                                    p.open = true;
                                }
                                p = p.parentElement;
                            }
                        } else {
                            s.classList.remove('bg-warning-subtle');
                        }
                    });
                    return;
                }

                if (mode === 'summary') {
                    // Hide non-matching person cards (cards are the rounded bordered blocks)
                    const cards = summaryHost.querySelectorAll('.p-2.border.rounded');
                    if (!q) { cards.forEach(c => c.classList.remove('d-none')); return; }
                    const ql = q.toLowerCase();
                    cards.forEach(c => {
                        const match = (c.textContent || '').toLowerCase().includes(ql);
                        c.classList.toggle('d-none', !match);
                    });
                    return;
                }

                if (mode === 'raw')    highlightPre(preRaw,   sourceRaw,   q);
                if (mode === 'pretty') highlightPre(prePretty, sourcePretty, q);
            }

            // Wire search inputs
            search?.addEventListener('input', applySearch);
            clearSearch?.addEventListener('click', () => { if (search) search.value = ''; applySearch(); });

            // Ensure search re-applies on view updates
            const _updateView = updateView;
            updateView = function () {
                _updateView();
                applySearch();
            };

            // View init
            updateView();
        })();
    </script>
}